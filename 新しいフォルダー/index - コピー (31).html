<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>中盤限定囲碁（黒=あなた/白=AI）</title>
<style>
  /* 保険：画面最右端に最低限の余白を確保（右ピタ防止） */
body {
  font-family: system-ui, sans-serif;
  margin: 16px;
  padding-right: 12px;   /* ← これを追加（8〜16pxで好み調整） */
  box-sizing: border-box; /* 余白計算のズレ防止の保険 */
}

  .hud {
  margin:8px 0;
  display:flex;
  flex-direction: column;  /* ← これを追加する */
  gap:8px;                 /* 上下間隔に調整 */
}
  button { padding:8px 12px; border-radius:8px; border:1px solid #ccc; background:#fff; cursor:pointer; }
  .info { font-size:14px; color:#333; }


/* 盤ラッパー：必ず左寄せにする */
.board-wrap{
  display: flex;
  justify-content: flex-start;  /* 左寄せ固定 */
  width: 100%;
}

#sprintBtn {
  background-color: #3f51b5; /* 藍色 */
  color: white;
  border: none;
  padding: 8px 14px;
  border-radius: 6px;
  cursor: pointer;
}
#sprintBtn:hover {
  background-color: #303f9f; /* 濃い藍色 */
}

#resetBtn {
  background-color: #8d6e63; /* 灰茶 */
  color: white;
  border: none;
  padding: 8px 14px;
  border-radius: 6px;
  cursor: pointer;
}
#resetBtn:hover {
  background-color: #6d4c41; /* 濃い灰茶 */
}



  
/* タッチ最適化：合成click遅延とダブルタップズームを抑止 */
.board, .cell, .hud button {
  touch-action: manipulation;
  -webkit-tap-highlight-color: transparent;
  user-select: none;
  -webkit-user-select: none;
}
/* 盤は木目画像に置換（格子線＆星は画像側） */
  .board{
    position:relative;
    display:grid;
    grid-template-columns:repeat(19,28px);
    grid-template-rows:repeat(19,28px);
    width:calc(19 * 28px);
    height:calc(19 * 28px);
    background:url("./board_19x19_3.png") no-repeat center/cover;
    background-size: 101% 101%;

  margin-right: 16px;   /* 好みで 8〜16px 程度 */
  margin-left: 0;
  float: none;          /* 念のためのリセット */


  }
  .board-wrap, .board { text-align: initial; }

  .cell{
    width:28px; height:28px;
    background:transparent;   /* 画像を透過させる */
    position:relative;
    cursor:pointer;
  }

  /* 石は画像で描画（余白は inset で微調整） */
  .stone{
    position:absolute;
    inset:0px;                /* 2〜4で微調整可 */
    border-radius:80%;
    background-position:center;
    background-size:135%;
    background-repeat:no-repeat;
    box-shadow:none;
    pointer-events:none;      /* クリックはセルに通す */
  }
  .black{ background-image:url("./black.png"); }
  .white{ background-image:url("./white.png"); }

  /* 最終手ハイライト（差分だけ見せる） */
  .lastmove::after{
    content:"";
    position:absolute;
    width:10px; height:10px;
    border:2px solid red;
    border-radius:50%;
    top:50%; left:50%;
    transform:translate(-50%,-50%);
    pointer-events:none;
  }

  /* ▼ 追加：ゴースト石（半透明） */
.stone.ghost{
  pointer-events: none;
  width:35px;      /* 28pxマスより小さく */
  height:35px;
  opacity:0.55;
  transform: translate(-50%, -50%);
  display:none;
  z-index:10;      /* 石より上に出す */
  inset:auto;       /* ← ここを追加：insetを無効化（top/leftはJSで設定） */
  /* （明示派なら）right:auto; bottom:auto; でもOK */

}

  .eval { margin-top: 8px; font-size: 14px; color: #222; }
</style>
</head>
<body>
  <h2>中盤限定囲碁（黒=あなた/白=AI）</small></h2>

<div class="hud">
  <!-- 上段：評価値 -->
  <div class="hud-row">
    <div class="eval" id="eval">評価値: -</div>
    <div class="eval" id="evalFirst">初手評価: （未保存）</div>
  </div>

  <!-- 下段：ボタン群 -->
  <div class="hud-row">
<button id="sprintBtn">中盤読み込み</button>
<button id="resetBtn">盤をクリア</button>    
    <label>強さ:
      <select id="difficulty">
        <option value="easy">弱い</option>
        <option value="normal" selected>普通</option>
        <option value="hard">強い</option>
      </select>
    </label>
    <span class="info" id="status">黒番です。</span>
  </div>
</div>

  <!-- ▼ 変更：board の子としてゴースト要素を1つ置く -->
  <div id="board" class="board">
    <div id="ghost" class="stone ghost"></div>
  </div>

  <pre id="last" style="margin-top:12px; background:#fafafa; padding:8px; border:1px solid #eee; border-radius:8px; max-height:220px; overflow:auto;"></pre>

<script>

let moveLimit = 40;          // 手数上限
let firstEvalWinrate = null; // 初手黒勝率（0〜1）
let moveStart = 0;           // ← 読み込み後の“開始位置”


// 追加: HUD更新関数（残り手数/優劣）
function updateStatusHud(currentBlackWin = null) {


  const progressed = Math.max(0, moves.length - moveStart);
  const remaining  = Math.max(0, moveLimit - progressed);


  document.getElementById("eval").textContent = `残り手数: ${remaining}`;

  let advText = '（未計算）';
  if (firstEvalWinrate !== null && currentBlackWin !== null) {
    const diffPct = (currentBlackWin - firstEvalWinrate) * 100; // 現在 − 初期
    const sign = diffPct >= 0 ? '+' : '';
    advText = `${sign}${diffPct.toFixed(1)}%`;
  }
  document.getElementById("evalFirst").textContent = `優劣: ${advText}`;
}

const N = 19;
const boardEl = document.getElementById('board');
const statusEl = document.getElementById('status');
const lastEl = document.getElementById('last');
//const maxVisitsEl = document.getElementById('maxVisits');
const resetBtn = document.getElementById('resetBtn');
const sprintBtn = document.getElementById('sprintBtn');

 // エンジンが「手番視点」で返してきても、UIは常に“黒視点”に正規化する
 // 'BLACK' | 'WHITE' | 'PLAYER_TO_MOVE'
 const REPORT_AS = 'PLAYER_TO_MOVE';
const evalFirstEl = document.getElementById('evalFirst');

function renderFirstEvalFromStorage(){
  try{
    const s = localStorage.getItem('firstEval');
    if(!s){ firstEvalWinrate = null; return; }
    const r = JSON.parse(s);
    firstEvalWinrate = (r.blackWinPct ?? 0) / 100;
  }catch{
    firstEvalWinrate = null;
  }
}

// 0=空, 1=黒, 2=白
let board = Array.from({length:N}, () => Array(N).fill(0));
let moves = []; // [["B","K10"],["W","D16"],...]
let blackBaseline = 0;   // ← ロード時点の黒手数を保持
let yourTurn = true; // 黒から

// ▼ 追加：ゴースト制御
const CELL = 28;
let ghost = null;                 // {x,y} or null
let ghostTimer = null;
const ghostEl = document.getElementById('ghost');

function xyCenterPx(x,y){
  // boardはposition:relative。交点中心に配置
  return { left: x*CELL + CELL/2, top: y*CELL + CELL/2 };
}
function showGhost(x,y){
  ghost = {x,y};
  const p = xyCenterPx(x,y);
  ghostEl.style.left = p.left + 'px';
  ghostEl.style.top  = p.top  + 'px';
  // 黒番（youの手）なので黒画像を表示
  ghostEl.style.backgroundImage = 'url("./black.png")';
  ghostEl.style.display = 'block';
  statusEl.textContent = "もう一度同じ点をタップで確定（2秒でキャンセル）";

  if (ghostTimer) { clearTimeout(ghostTimer); ghostTimer = null; }
  ghostTimer = setTimeout(() => {
    clearGhost();
    statusEl.textContent = "黒番です。セルをタップ/クリックして着手してください。";
  }, 2000);


}
function clearGhost(){

  ghost = null;
  ghostEl.style.display = 'none';
  ghostEl.style.left = '-9999px';  // 退避（保険）
  ghostEl.style.top  = '-9999px';
  if (ghostTimer) {
    clearTimeout(ghostTimer);
    ghostTimer = null;
  }

}

// 座標（Iを飛ばす）
const letters = "ABCDEFGHJKLMNOPQRST".split("");
function toCoord(x,y){ const col=letters[x]; const row=(N-y).toString(); return col+row; }

function neighbors(x,y){ return [[x-1,y],[x+1,y],[x,y-1],[x,y+1]].filter(([a,b])=>a>=0&&a<N&&b>=0&&b<N); }
function flood(x,y,color,vis=new Set()){
  const key=`${x},${y}`; if(vis.has(key)) return {stones:[],libs:new Set()};
  vis.add(key);
  let stones=[[x,y]], libs=new Set();
  for(const [nx,ny] of neighbors(x,y)){
    if(board[ny][nx]===0) libs.add(`${nx},${ny}`);
    else if(board[ny][nx]===color){
      const r=flood(nx,ny,color,vis);
      stones = stones.concat(r.stones);
      r.libs.forEach(s=>libs.add(s));
    }
  }
  return {stones,libs};
}
function place(color,x,y){
  if(board[y][x]!==0) return false;
  const me = color==='B'?1:2;
  const opp= color==='B'?2:1;
  board[y][x]=me;

  // アゲハマ
  let captured=0;
  for(const [nx,ny] of neighbors(x,y)){
    if(board[ny][nx]===opp){
      const g=flood(nx,ny,opp,new Set());
      if(g.libs.size===0){
        for(const [sx,sy] of g.stones){ board[sy][sx]=0; captured++; }
      }
    }
  }
  // 自殺禁止（直前取りで助かっていればOK）
  const mine=flood(x,y,me,new Set());
  if(mine.libs.size===0 && captured===0){ board[y][x]=0; return false; }
  return true;
}

/* 最後の一手だけマーク */
function draw(){
  boardEl.innerHTML="";
  // ゴーストをboard内に保持したいので、毎回再挿入
  boardEl.appendChild(ghostEl);

  const last = moves[moves.length-1];
  let lastX=-1,lastY=-1;
  if(last){
    const colLetter=last[1][0];
    const rowNum=parseInt(last[1].slice(1),10);
    lastX=letters.indexOf(colLetter);
    lastY=N-rowNum;
  }
  for(let y=0;y<N;y++) for(let x=0;x<N;x++){
    const cell=document.createElement('div');
    cell.className='cell';
    const v=board[y][x];
    if(v){
      const st=document.createElement('div');
      st.className='stone ' + (v===1?'black':'white');
      if(x===lastX && y===lastY) st.classList.add('lastmove');
      cell.appendChild(st);
    }

    // ▼ 差し替え：二段階タップ
    const handler = async (e)=>{
      if(e && e.pointerType && e.pointerType!=='mouse') e.preventDefault();
      if(!yourTurn) return;
      if(ghost && ghost.x===x && ghost.y===y){
        // 確定
        clearGhost();
        if(!place('B',x,y)){ statusEl.textContent="そこには打てません。別の点を。"; return; }

        try {
          const humanMove = toCoord(x,y);
          window.AiMoveNLP?.reactToHumanMove?.(humanMove);
        } catch {}

        moves.push(["B", toCoord(x,y)]);
        updateStatusHud(null);        // ★追加：1着手ぶん残りを減らす
        yourTurn=false;
        statusEl.textContent="AI思考中…";
        draw();
        await aiReply();
      } else {
        // 1回目：ゴースト表示
        showGhost(x,y);
      }
    };
    cell.addEventListener('pointerdown', handler, {passive:false});

    boardEl.appendChild(cell);
  }
}

async function aiReply(){
  try{
    //const maxVisits = parseInt(maxVisitsEl.value || "2", 10);
    const maxVisits = 2;

    const payload = {
      rules:"japanese", komi:6.5,
      boardXSize:N, boardYSize:N,
      maxVisits, moves
    };
    const resp = await fetch("/api/analyze", {
      method:"POST",
      headers:{"Content-Type":"application/json"},
      body:JSON.stringify(payload),
    });

    const data = await resp.json();
    lastEl.textContent = JSON.stringify(data.katago, null, 2);

    // ここで先に宣言（ブロックスコープ外に出す）
    let blackWin = null;


    const root = data?.katago?.rootInfo;
    if (root) {

      // === 常に“黒視点”へ正規化 ===
      const isWhiteToMove = root.currentPlayer === 'W';
      // 勝率（0..1）：手番視点→黒視点へ変換
      blackWin = root.winrate;
      if (REPORT_AS === 'WHITE') blackWin = 1 - blackWin;
      if (REPORT_AS === 'PLAYER_TO_MOVE' && isWhiteToMove) blackWin = 1 - blackWin;
      const whiteWin = 1 - blackWin;
      // リード（目数）：手番視点→黒視点へ変換
      let leadBlack = (root.scoreLead ?? 0);
      if (REPORT_AS === 'PLAYER_TO_MOVE' && isWhiteToMove) leadBlack = -leadBlack;


      // --- 初手評価の保存（このセッションで最初のあなたの黒手）---
      const blackCount = moves.filter(([bw]) => bw === "B").length;
      const isUsersFirstBlack = blackCount === blackBaseline + 1;
      if (isUsersFirstBlack && !localStorage.getItem('firstEval')) {
        const lastBlackMove = [...moves].reverse().find(m => m[0] === "B")?.[1] ?? null;
        const rec = {
          ts: Date.now(),
          move: lastBlackMove,
          blackWinPct: blackWin * 100,
          whiteWinPct: whiteWin * 100,
          scoreLead: leadBlack
        };
        localStorage.setItem('firstEval', JSON.stringify(rec));
        renderFirstEvalFromStorage();

        // ★ 初手評価の黒勝率を保持（0〜1の小数）
        firstEvalWinrate = blackWin;
      }
    } else {
      // ここでは status だけ通知し、HUD は後で updateStatusHud(null) が担当
      statusEl.textContent = "評価値: 取得できませんでした";
    }

    // root が無い場合は null のまま渡す
    updateStatusHud(blackWin);


    const mv = data.bestMove;
    if(!mv){ statusEl.textContent="AIの手が得られませんでした。"; yourTurn=true; return; }
    const x = letters.indexOf(mv[0]);
    const y = N - parseInt(mv.slice(1),10);
    if(x<0||y<0||x>=N||y>=N){ statusEl.textContent=`不正な手: ${mv}`; yourTurn=true; return; }
    if(!place('W',x,y)){ statusEl.textContent=`AI手(${mv})がUIで置けませんでした。`; yourTurn=true; draw(); return; }
    moves.push(["W", mv]);
    draw();
    updateStatusHud(blackWin);   // ★追加：AI着手後も残りを減らす

    // ★存在すればコメント生成。無ければ何も起こらない
    try { window.AiMoveNLP?.describe({ bestMove: mv, katago: data.katago, moves }); } catch {}

    statusEl.textContent="黒番です。";
    yourTurn=true;
  }catch(e){
    statusEl.textContent="通信エラー: "+e;
    yourTurn=true;
  }
}

resetBtn.addEventListener('click', ()=>{

firstEvalWinrate = null;        // ★追加
updateStatusHud(null);          // ★追加


  clearGhost(); // ▼ 追加：リセット時にゴーストも消す
  board = Array.from({length:N},()=>Array(N).fill(0));
  moves=[]; yourTurn=true;
  moveStart = moves.length;       // ★追加：0を基準へ
  lastEl.textContent="";
  statusEl.textContent="黒番です。セルをタップ/クリックして着手してください。";
  blackBaseline = 0; // クリア時は0から
  localStorage.removeItem('firstEval');
  renderFirstEvalFromStorage();
  draw();
});

// ランダム初期局面
function applyMoves(mvList){
  clearGhost(); // 念のため
  board = Array.from({length:N},()=>Array(N).fill(0));
  moves=[]; yourTurn=true;
  for(const [bw,coord] of mvList){
    const x=letters.indexOf(coord[0]);
    const y=N - parseInt(coord.slice(1),10);
    if(x<0||y<0||x>=N||y>=N) continue;
    place(bw,x,y);
    moves.push([bw,coord]);
  }
  draw();
  const blackToMove = (moves.length%2===0);
  yourTurn = blackToMove;
  if(blackToMove){
    statusEl.textContent="黒番です（ランダム初期盤面）。";
  }else{
    statusEl.textContent="白番です。AIの着手を待っています…";
    aiReply();
  }

  // 読み込み直後の黒手数を基準にする
  blackBaseline = moves.filter(([bw]) => bw === "B").length;

  // 初手評価は毎回未保存から
  localStorage.removeItem('firstEval');
  renderFirstEvalFromStorage();

  firstEvalWinrate = null;        // ★維持
  // ★ この時点を“開始位置”として記録（←先にやる）
  moveStart = moves.length;
  updateStatusHud(null);          // ★その後にHUD更新
}

sprintBtn.addEventListener("click", async ()=>{
  statusEl.textContent="初期局面を取得中…";
  const resp = await fetch("/api/sprint/random");
  const data = await resp.json();
  if(!data.ok){ statusEl.textContent="初期局面取得失敗: "+(data.error||""); return; }
  applyMoves(data.moves||[]);

  lastEl.textContent="Loaded recId: "+(data.recId??"(unknown)")+"\n"+JSON.stringify({moves:data.moves},null,2);

  // ★ここで残り手数を40にセット
  moveLimit = 40;
  updateStatusHud(null);


});





// 初期描画（ロード時は必ず未保存から）
localStorage.removeItem('firstEval');
renderFirstEvalFromStorage();
updateStatusHud(null);          // ★追加
draw();
</script>
<script src="./aiComment.js"></script>
</body>
</html>
