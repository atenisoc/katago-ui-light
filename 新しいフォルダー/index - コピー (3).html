<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>KataGo 最小対局UI (黒=あなた / 白=AI)</title>
<style>
  body { font-family: system-ui, sans-serif; margin: 16px; }
  .board { display: grid; grid-template-columns: repeat(19, 28px); grid-template-rows: repeat(19, 28px); gap: 2px; }
  .cell { width: 28px; height: 28px; background: #d7b77a; position: relative; border-radius: 4px; cursor: pointer; }
  .hoshi::after { content:""; position:absolute; width:6px; height:6px; background:#333; border-radius:50%; top:50%; left:50%; transform:translate(-50%,-50%); }
  .stone { position:absolute; inset:3px; border-radius:50%; box-shadow: inset 0 1px 2px rgba(0,0,0,.4); }
  .black { background:#111; }
  .white { background:#f4f4f4; border:1px solid #ccc; }
  .hud { margin: 8px 0; display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
  button { padding:8px 12px; border-radius:8px; border:1px solid #ccc; background:#fff; cursor:pointer; }
  .info { font-size:14px; color:#333; }
</style>
</head>
<body>
  <h2>KataGo 最小対局UI <small>(黒=あなた / 白=AI)</small></h2>
  <div class="hud">
    <button id="resetBtn">盤をクリア</button>
    <label>時間上限(s): <input id="maxTime" type="number" min="1" step="1" value="5" style="width:60px"></label>
    <span class="info" id="status">黒番です。セルをクリックして着手してください。</span>
<button id="sprintBtn">スプリント開始（ランダム）</button>
<label>ID: <input id="sprintId" type="text" placeholder="game_000042.sgf" style="width:160px"></label>
<button id="sprintByIdBtn">IDで開始</button>
<label><input type="checkbox" id="toggleLast" checked> 最終着手を表示</label>

  </div>



  <div id="board" class="board"></div>
  <pre id="last" style="margin-top:12px; background:#fafafa; padding:8px; border:1px solid #eee; border-radius:8px; max-height:220px; overflow:auto;"></pre>

<script>
const N = 19;
const boardEl = document.getElementById('board');
const statusEl = document.getElementById('status');
const lastEl = document.getElementById('last');
const maxTimeEl = document.getElementById('maxTime');
const resetBtn = document.getElementById('resetBtn');

// 0=空, 1=黒, 2=白
let board = Array.from({length:N}, () => Array(N).fill(0));
let moves = []; // [["B","K10"],["W","D16"],...]
let yourTurn = true; // 黒から

// 座標ヘルパ（Iを飛ばす）
const letters = "ABCDEFGHJKLMNOPQRST".split(""); // no I
function toCoord(x, y) { // x=0左, y=0上
  const col = letters[x];
  const row = (N - y).toString(); // 上が19
  return col + row;
}

// 置石＆シンプルな取り（自殺禁止/コウ未対応=最小実装）
function neighbors(x,y) {
  return [[x-1,y],[x+1,y],[x,y-1],[x,y+1]].filter(([a,b]) => a>=0&&a<N&&b>=0&&b<N);
}
function flood(x,y,color,vis=new Set()) {
  const key = `${x},${y}`;
  if (vis.has(key)) return {stones:[],libs:new Set()};
  vis.add(key);
  let stones = [[x,y]];
  let libs = new Set();
  for (const [nx,ny] of neighbors(x,y)) {
    if (board[ny][nx] === 0) libs.add(`${nx},${ny}`);
    else if (board[ny][nx] === color) {
      const r = flood(nx,ny,color,vis);
      stones = stones.concat(r.stones);
      r.libs.forEach(s=>libs.add(s));
    }
  }
  return {stones, libs};
}
function place(color, x, y) {
  if (board[y][x] !== 0) return false;
  const me = color === 'B' ? 1 : 2;
  const opp = color === 'B' ? 2 : 1;
  board[y][x] = me;

  // 相手グループのアゲハマ
  let captured = 0;
  for (const [nx,ny] of neighbors(x,y)) {
    if (board[ny][nx] === opp) {
      const g = flood(nx,ny,opp,new Set());
      if (g.libs.size === 0) {
        for (const [sx,sy] of g.stones) { board[sy][sx] = 0; captured++; }
      }
    }
  }
  // 自分のグループの呼吸確認（自殺禁止。ただし直前の取りで助かっていればOK）
  const mine = flood(x,y,me,new Set());
  if (mine.libs.size === 0 && captured === 0) { board[y][x] = 0; return false; }
  return true;
}

function draw() {
  boardEl.innerHTML = "";
  for (let y=0;y<N;y++) for (let x=0;x<N;x++) {
    const cell = document.createElement('div');
    cell.className = 'cell';
    // 星の目
    const hoshi = (
      (x===3||x===9||x===15) && (y===3||y===9||y===15)
    );
    if (hoshi) cell.classList.add('hoshi');
    // 石
    const v = board[y][x];
    if (v) {
      const st = document.createElement('div');
      st.className = 'stone ' + (v===1?'black':'white');
      cell.appendChild(st);
    }
    // クリック
    cell.addEventListener('click', async () => {
      if (!yourTurn) return;
      if (!place('B', x, y)) { statusEl.textContent = "そこには打てません。別の点を。"; return; }
      moves.push(["B", toCoord(x,y)]);
      yourTurn = false;
      statusEl.textContent = "AI思考中…";
      draw();
      await aiReply();
    });
    boardEl.appendChild(cell);
  }
  placeLastMarker();
}

async function aiReply() {
  try {
    const maxTime = parseInt(maxTimeEl.value || "5", 10);
    const resp = await fetch("/api/analyze", {
      method:"POST",
      headers:{"Content-Type":"application/json"},
      body: JSON.stringify({ moves, maxTime, rules:"japanese", komi:6.5 }),
    });
    const data = await resp.json();
    lastEl.textContent = JSON.stringify(data.katago, null, 2);

    const mv = data.bestMove; // e.g. "D4"
    if (!mv) { statusEl.textContent = "AIの手が得られませんでした。"; yourTurn=true; return; }

    // "K10" -> x,y
    const colLetter = mv[0];
    const rowNum = parseInt(mv.slice(1),10);
    const x = letters.indexOf(colLetter);
    const y = N - rowNum;

    if (x<0 || y<0 || x>=N || y>=N) {
      statusEl.textContent = `不正な手: ${mv}`;
      yourTurn = true;
      return;
    }
    if (!place('W', x, y)) {
      // 置けないことは基本無いはずだが、一応置けるまでズラすことはしない（最小実装）
      statusEl.textContent = `AI手(${mv})がUIで置けませんでした。`;
      yourTurn = true;
      draw();
      return;
    }
    moves.push(["W", mv]);
    draw();
    statusEl.textContent = "黒番です。";
    yourTurn = true;
  } catch (e) {
    statusEl.textContent = "通信エラー: " + e;
    yourTurn = true;
  }
}

resetBtn.addEventListener('click', () => {
  board = Array.from({length:N}, () => Array(N).fill(0));
  moves = [];
  yourTurn = true;
  lastEl.textContent = "";
  statusEl.textContent = "黒番です。セルをクリックして着手してください。";
  draw();
});

draw();
</script>
</body>
</html>

