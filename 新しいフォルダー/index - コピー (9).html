<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>KataGo 最小対局UI (黒=あなた / 白=AI)</title>
<style>
  body { font-family: system-ui, sans-serif; margin: 16px; }
  .hud { margin: 8px 0; display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
  button { padding:8px 12px; border-radius:8px; border:1px solid #ccc; background:#fff; cursor:pointer; }
  .info { font-size:14px; color:#333; }

  .board { display: grid; grid-template-columns: repeat(19, 28px); grid-template-rows: repeat(19, 28px); gap: 2px; }
  .cell { width: 28px; height: 28px; background: #d7b77a; position: relative; border-radius: 4px; cursor: pointer; }
  .hoshi::after { content:""; position:absolute; width:6px; height:6px; background:#333; border-radius:50%; top:50%; left:50%; transform:translate(-50%,-50%); }
  .stone { position:absolute; inset:3px; border-radius:50%; box-shadow: inset 0 1px 2px rgba(0,0,0,.4); }
  .black { background:#111; }
  .white { background:#f4f4f4; border:1px solid #ccc; }

  /* ▼ 追加：最終手ハイライト（赤い丸） */
  .lastmove::after {
    content:"";
    position:absolute;
    width:10px; height:10px;
    border:2px solid red;
    border-radius:50%;
    top:50%; left:50%;
    transform:translate(-50%,-50%);
    pointer-events:none;
  }
</style>
</head>
<body>
  <h2>KataGo 最小対局UI <small>(黒=あなた / 白=AI)</small></h2>

  <div class="hud">
    <button id="sprintBtn">スプリント開始（ランダム）</button>
    <button id="resetBtn">盤をクリア</button>
    <label>訪問回数: <input id="maxVisits" type="number" min="1" step="1" value="4" style="width:60px"></label>
    <span class="info" id="status">黒番です。セルをクリックして着手してください。</span>
  </div>

  <div id="board" class="board"></div>
  <pre id="last" style="margin-top:12px; background:#fafafa; padding:8px; border:1px solid #eee; border-radius:8px; max-height:220px; overflow:auto;"></pre>

<script>
const N = 19;
const boardEl = document.getElementById('board');
const statusEl = document.getElementById('status');
const lastEl = document.getElementById('last');
const maxVisitsEl = document.getElementById('maxVisits');
const resetBtn = document.getElementById('resetBtn');
const sprintBtn = document.getElementById('sprintBtn');

// 0=空, 1=黒, 2=白
let board = Array.from({length:N}, () => Array(N).fill(0));
let moves = []; // [["B","K10"],["W","D16"],...]
let yourTurn = true; // 黒から

// 座標（Iを飛ばす）
const letters = "ABCDEFGHJKLMNOPQRST".split(""); // no I
function toCoord(x, y) { // x=0左, y=0上
  const col = letters[x];
  const row = (N - y).toString(); // 上が19
  return col + row;
}

function neighbors(x,y) { return [[x-1,y],[x+1,y],[x,y-1],[x,y+1]].filter(([a,b]) => a>=0&&a<N&&b>=0&&b<N); }
function flood(x,y,color,vis=new Set()) {
  const key = `${x},${y}`; if (vis.has(key)) return {stones:[],libs:new Set()};
  vis.add(key);
  let stones = [[x,y]], libs = new Set();
  for (const [nx,ny] of neighbors(x,y)) {
    if (board[ny][nx] === 0) libs.add(`${nx},${ny}`);
    else if (board[ny][nx] === color) {
      const r = flood(nx,ny,color,vis);
      stones = stones.concat(r.stones);
      r.libs.forEach(s=>libs.add(s));
    }
  }
  return {stones, libs};
}
function place(color, x, y) {
  if (board[y][x] !== 0) return false;
  const me = color === 'B' ? 1 : 2;
  const opp = color === 'B' ? 2 : 1;
  board[y][x] = me;

  // 相手グループのアゲハマ
  let captured = 0;
  for (const [nx,ny] of neighbors(x,y)) {
    if (board[ny][nx] === opp) {
      const g = flood(nx,ny,opp,new Set());
      if (g.libs.size === 0) {
        for (const [sx,sy] of g.stones) { board[sy][sx] = 0; captured++; }
      }
    }
  }
  // 自分のグループの呼吸確認（自殺禁止。ただし直前の取りで助かっていればOK）
  const mine = flood(x,y,me,new Set());
  if (mine.libs.size === 0 && captured === 0) { board[y][x] = 0; return false; }
  return true;
}

/* ▼ 修正：最後の手だけに .lastmove を付与して差分強調 */
function draw() {
  boardEl.innerHTML = "";
  // 最後の着手の座標を算出
  const last = moves[moves.length - 1];
  let lastX = -1, lastY = -1;
  if (last) {
    const colLetter = last[1][0];
    const rowNum = parseInt(last[1].slice(1), 10);
    lastX = letters.indexOf(colLetter);
    lastY = N - rowNum;
  }

  for (let y=0;y<N;y++) for (let x=0;x<N;x++) {
    const cell = document.createElement('div');
    cell.className = 'cell';
    if ((x===3||x===9||x===15) && (y===3||y===9||y===15)) cell.classList.add('hoshi');
    const v = board[y][x];
    if (v) {
      const st = document.createElement('div');
      st.className = 'stone ' + (v===1?'black':'white');
      // ここで最終手にのみ赤丸を表示
      if (x===lastX && y===lastY) st.classList.add('lastmove');
      cell.appendChild(st);
    }
    cell.addEventListener('click', async () => {
      if (!yourTurn) return;
      if (!place('B', x, y)) { statusEl.textContent = "そこには打てません。別の点を。"; return; }
      moves.push(["B", toCoord(x,y)]);
      yourTurn = false;
      statusEl.textContent = "AI思考中…";
      draw();
      await aiReply();
    });
    boardEl.appendChild(cell);
  }
}

async function aiReply() {
  try {
    const maxVisits = parseInt(maxVisitsEl.value || "4", 10);

    const payload = {
      rules: "japanese",
      komi: 6.5,
      boardXSize: N,
      boardYSize: N,
      maxVisits,
      moves
    };


    const resp = await fetch("/api/analyze", {
      method:"POST",
      headers:{"Content-Type":"application/json"},
      body: JSON.stringify(payload),
    });
    const data = await resp.json();
    lastEl.textContent = JSON.stringify(data.katago, null, 2);

    const mv = data.bestMove; // e.g. "D4"
    if (!mv) { statusEl.textContent = "AIの手が得られませんでした。"; yourTurn=true; return; }

    const colLetter = mv[0];
    const rowNum = parseInt(mv.slice(1),10);
    const x = letters.indexOf(colLetter);
    const y = N - rowNum;

    if (x<0 || y<0 || x>=N || y>=N) {
      statusEl.textContent = `不正な手: ${mv}`; yourTurn = true; return;
    }
    if (!place('W', x, y)) {
      statusEl.textContent = `AI手(${mv})がUIで置けませんでした。`; yourTurn = true; draw(); return;
    }
    moves.push(["W", mv]);
    draw();
    statusEl.textContent = "黒番です。";
    yourTurn = true;
  } catch (e) {
    statusEl.textContent = "通信エラー: " + e;
    yourTurn = true;
  }
}

resetBtn.addEventListener('click', () => {
  board = Array.from({length:N}, () => Array(N).fill(0));
  moves = [];
  yourTurn = true;
  lastEl.textContent = "";
  statusEl.textContent = "黒番です。セルをクリックして着手してください。";
  draw();
});

// ランダム初期局面の適用
function applyMoves(mvList) {
  board = Array.from({length:N}, ()=>Array(N).fill(0));
  moves = [];
  yourTurn = true;
  for(const [bw,coord] of mvList){
    const col=coord[0];
    const rowNum=parseInt(coord.slice(1),10);
    const x=letters.indexOf(col);
    const y=N-rowNum;
    if(x<0||y<0||x>=N||y>=N) continue;
    place(bw,x,y);
    moves.push([bw,coord]);
  }
  draw();
  const blackToMove=(moves.length%2===0);
  yourTurn=blackToMove;
  if(blackToMove){
    statusEl.textContent="黒番です（ランダム初期盤面）。";
  } else {
    statusEl.textContent="白番です。AIの着手を待っています…";
    aiReply();
  }
}
sprintBtn.addEventListener("click", async()=>{
  statusEl.textContent="初期局面を取得中…";
  const resp = await fetch("/api/sprint/random");
  const data = await resp.json();
  if(!data.ok){
    statusEl.textContent="初期局面取得失敗: "+(data.error||"");
    return;
  }
  applyMoves(data.moves||[]);
  lastEl.textContent="Loaded recId: "+(data.recId??"(unknown)")+"\n"+JSON.stringify({moves:data.moves},null,2);
});

// 初期描画
draw();
</script>
</body>
</html>
